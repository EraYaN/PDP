%!TEX program = xelatex
%!TEX spellcheck = en_GB
\documentclass[final]{article}
\input{../../.library/preamble.tex}
\input{../../.library/style.tex}
\addbibresource{../../.library/bibliography.bib}
\begin{document}
\section{Improvements}
\subsection{Attempted}
\subsubsection{Cache}
\subsubsection{Pipeline}
\subsubsection{Branching}
\subsection{Succeeded}
\subsubsection{Cache}
\subsubsection{Multiplier}
\subsubsection{Divider}
%Size = FIFO=14 Slice = 4623
%Size without: FIFO = 14 Slice = 4163
\Cref{fig:instruction-count} shows that very few of the instructions executed in the benchmarks are divisions. This fact initially discouraged attempting to improve the divider. However, after multiple attempts at improving the processor in other areas proved to be unfruitful it was decided to take a second look at the divider anyway. While a small percentage of the instructions are divisions, one single division still takes 32 cycles making the impact on the performance of the processor more significant than \cref{}fig:instruction-count} may suggest. 

The original implementation of the division algorithm in the processor is a very simple shift and subtract algorithm. It shifts the divisor to the right attempting to subtract it from the dividend along the way. If the resulting value remains positive it saves the partial remainder and writes a '1' to the quotient, otherwise it does not subtract and it writes a '0'. It was decided to attempt improving the divider by implementing it as a higher radix divider as described by chapter 14 of the book Computer Arithmetic: Algorithms and Hardware Designs by B. Parhami \cite{parhami}. Upgrading to a radix-4 divider should already provide a speed-up of 2x as 2 bits of the quotient are now calculated in the same cycle.

In order to accomplish calculating 2 bits per cycle the divisor ($d$) multiples $2d$ and $3d$ had to be pre-calculated. For $3d$ this required an adder, $2d$ is just a left shift of the divisor. Every cycle, the divisor and its multiples are shifted 2 bits to the right and subtracted from the dividend. Writing "11", "10" or "01" to the quotient if the $3d$, $2d$ or $1d$ subtraction leaves a positive partial remainder respectively. It then saves the partial remainder. If none of the subtractions leaves a positive partial remainder "00" is written to the quotient.

This implementation succeeds at reducing the division from 32 cycles to 16 cycles, reducing the total execution time of all the benchmarks with 117 million cycles. Unfortunately the extra adders necessary for subtractions and pre-calculating the divisor multiples add a significant amount of area to the processor. With the $A_{CLB}$ as defined in \cref{sec:baseperf} increasing by 115.

\end{document}